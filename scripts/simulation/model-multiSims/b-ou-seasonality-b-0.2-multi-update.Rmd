---
title: "Time-varying parametric reported probability: OU process"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(cmdstanr)
library(splines)
library(ggplot2)
library(reshape2)
library(dplyr)
library(bayesplot)
library(scoringRules)
library(purrr)
```

```{r}
path_proj = here::here()
path_source_nowcasting <- file.path(dirname(path_proj), "nowcasting", "source")

source(file.path(path_source_nowcasting, "simulation", "simulations_functions_final.R"))
source(file.path(path_source_nowcasting, "functions", "prior_function.R"))
post_draws_path_NFRM = file.path(file.path(dirname(dirname(path_proj)),"projects","draws","NFRM"))

source(file.path(path_proj, "source", "functions", "simulation_functions.R"))

error_metrics <- function(predicted, actual) {
  # same length
  stopifnot(length(predicted) == length(actual))
  
  # RMSE (Root Mean Squared Error)
  rmse <- sqrt(mean((predicted - actual)^2))
  
  # RMSPE (Root Mean Squared Percentage Error)
  rmspe <- sqrt(mean(((predicted - actual)/actual)^2)) * 100
  
  # MAE (Mean Absolute Error)
  mae <- mean(abs(predicted - actual))
  
  # MAPE (Mean Absolute Percentage Error)
  mape <- mean(abs((predicted - actual)/actual)) * 100

  list(RMSE = rmse,
       RMSPE = rmspe,
       MAE = mae,
       MAPE = mape)
}


```

```{r}
b_ou <-  file.path(path_source_nowcasting, "models", "b-ou.stan")
model_bsl <- cmdstan_model(b_ou)

#file.path(dirname(dirname(path_proj)),"cmdstan-2.32.0")
#set_cmdstan_path(file.path(dirname(dirname(path_proj)),"cmdstan-2.32.0"))

b_ou_lambda <-  file.path(path_proj, "source", "models", "b-ou-GT-combined-seasonality-fourier-new.stan")
# b_ou_lambda <- file.path(path_proj, "source", "models", "b-ou-GT-time-varying-betas.stan")
model_prps <- cmdstan_model(b_ou_lambda)

#setting
iter_sampling = 2500
iter_warmup   = 1000
chains        = 4
refresh       = 0
thin          = 1
if_show_messages = F
```
# GT

```{r}
# --- preliminaries unchanged -------------------------------------------------
#set.seed(111)
years <- 3; weeks_per_yr <- 52; T_len <- years * weeks_per_yr
t     <- seq_len(T_len)
week  <- ((t - 1) %% weeks_per_yr) + 1
E     <- 1000

num_sims = 5
n_weeks   <-  c(105, 118, 131, 144, 156)
#n_weeks   <-  c(52)
lambda_seq_NFRM <- matrix(NA, ncol = T_len, nrow = num_sims)


# set the total var and ratio
total_var = 0.1

tau_epsilon <- 1
tau_ar <- 4
tau_cov <- 4

sigma_epsilon <- sqrt(total_var * tau_epsilon / (tau_epsilon + tau_ar + tau_cov))
sd_ar <- sqrt(total_var * tau_ar / (tau_epsilon + tau_ar + tau_cov))
beta1 <- sqrt(total_var * tau_cov / (tau_epsilon + tau_ar + tau_cov))

# --- seasonality ---------------------------------------------------
# --- baisc setting -------------------------------------------------
H_max <- 10            # harmonic
P     <- weeks_per_yr   # periodic

# --- Fourier basis -------------------------------------------------
# to each h，we generate cos(h*angle) and sin(h*angle)
angle <- 2 * pi * (t - 1) / P  # for each t we have one angle
fourier_list <- lapply(1:H_max, function(h) {
  cbind(
    cos_h = cos(h * angle),
    sin_h = sin(h * angle)
  )
})
fourier_basis <- do.call(cbind, fourier_list)
# column name
colnames(fourier_basis) <- unlist(lapply(1:H_max, function(h) {
  c(paste0("cos_h", h), paste0("sin_h", h))
}))

# (fixed, to make it simplier)
# --- coefficient beta_s for seasonality---------------------------------
set.seed(3)
H_used <- 5
ratio  <- c(10, 2, 1, 1, 1) # ratio of each frequency (SD)）  
sigma_s    <- 0.5                # total variance

# —— calc the scaling ratio c ——  
# total "share" of var：
sigma_s_raw <- sum(2 * (ratio^2))  
# scaling ratio：
c     <- sqrt(sigma_s / sigma_s_raw)  

# —— σ_h ——  
sd_h   <- ratio * c           
sd_all <- rep(sd_h, each = 2)  # twice，for each cos_h and sin_h  

# —— generate beta_s and s_t ——  
beta_s <- rnorm(2 * H_used, mean = 0, sd = sd_all)  
s_t    <- as.vector(fourier_basis[, 1:(2*H_used)] %*% beta_s)

# clear seeds
rm(.Random.seed, envir = .GlobalEnv)

# sims loop

for (i in 1:num_sims) {
  # --- (1) Independent noise ---------------------------------------------------
  #sigma_epsilon  <- 0.1
  epsilon_t    <- rnorm(T_len, mean = 0, sd = sigma_epsilon)
  
  # --- (2) Dependent noise ---------------------------------------------------
  # sigma_epsilon = sqrt((1- rho_w^2) * var_ar)
  #sd_ar <- 0.1
  rho_w <- 0.8
  sigma_w  <- sqrt((1-rho_w^2) * sd_ar^2)
  w_t <- arima.sim(model = list(ar = rho_w), n = T_len,
                   sd = sigma_w)
  
  # --- (3) covariate X_t -------------------------------------------------------
  #x_t <- scale(rnorm(T_len))[, 1]        # standard normal, independent of other components
  x_t <- rnorm(T_len) 
  #beta1     <- 0.1
  beta0 <- 0.2
  
  # --- (4) Risk -------------------------------------------------------
  log_lambda <- beta0 + beta1 * x_t + s_t + w_t + epsilon_t
  
  lambda_t   <- exp(log_lambda)
  mu_t  <- E * lambda_t
  
  lambda_seq_NFRM[i,] <- mu_t
}
lambda_seq_NFRM[1,1]
```

## Non-fully reported scenario

### Simulation - Not fully reported - Moderate

```{r}
D <- 15
data_NFRM <- list()

for (j in 1:num_sims) {
  data_NFRM[[j]] <- simulateData(
    params = list(
      data = list(
        lambda = lambda_seq_NFRM[j,],
        T       = T_len,
        date_start = as.Date("2024-01-01"),
        D = D
      ),
      q_model = list(
        method        = "b_ou",
        method_params = list(theta_logb = 0.7, mu_logb = log(0.2), init_logb = log(0.2), sigma_logb = 0.4,
                             theta_logitphi = 0.7, 
                             mu_logitphi = inverse_logistic_transform(0.2, 0, 1), 
                             init_logitphi = inverse_logistic_transform(0.2, 0, 1), sigma_logitphi = 0.15)
      )
    )
  )
}

par(mfrow = c(2, 3))
for (i in 1:num_sims) {
  matplot(t(data_NFRM[[i]]$q), type = "l", lty = 1, ylim = c(0, 1))
}


```

### Model fitting

```{r, warning=F}
t0_bsl_NFRM <- Sys.time()

# 1) param table
param_tbl_NFRM <- expand.grid(
  n_weeks = n_weeks,
  run     = seq_len(num_sims)
)

hypers = hypers_q(phi_ref = 0.1, D_ref = 25, type = "exponential", alpha_phi = 1.4, sd_log_b = 1, delay_seq = 0:15)
# 2) run everything

results_bsl_NFRM <- pmap(param_tbl_NFRM, function(n_weeks, run) {
  message("Simulating: ", n_weeks, " weeks — run ", run)
  
  stan_data <- c(
    list(
      T = n_weeks,
      D = D,
      Y = data_NFRM[[run]]$case_reported_cumulated[1:n_weeks, ]
    ),
    hypers
  )
suppressMessages(
  suppressWarnings(
      fit <- model_bsl$sample(
        data          = stan_data,
        iter_sampling = iter_sampling,
        iter_warmup   = iter_warmup,
        chains        = chains,
        parallel_chains = chains,
        refresh       = refresh,
        thin          = thin,
        show_messages = if_show_messages,
        output_dir = post_draws_path_NFRM
      )
    )
  )
  
  out <- list(
    files   = fit$output_files(),  # only save the path
    n_weeks = n_weeks,
    run     = run
  )
  rm(fit); gc()                    # release RAM
  out
})

# 4) Result (adress)

t1_bsl_NFRM <- Sys.time()
```

```{r}
t0_prps_NFRM <- Sys.time()
hypers = hypers_q(phi_ref = 0.1, D_ref = 25, type = "exponential", alpha_phi = 1.4, sd_log_b = 1, delay_seq = 0:15)

# run everything
results_prps_NFRM <- pmap(param_tbl_NFRM, function(n_weeks, run) {
  message("Simulating: ", n_weeks, " weeks — run ", run)
  
  stan_data <-     c(
    list(T = n_weeks, 
         D = D, 
         Y = data_NFRM[[run]]$case_reported_cumulated[1:n_weeks, ]), 
    hypers, 
    list(K = ncol(matrix(x_t)), 
         x = as.matrix(matrix(x_t)[1:n_weeks, 1]),
         S = H_used*2,  
         bases_s = fourier_basis[(1:n_weeks),1:(H_used*2)],
         E = E
    )
  )

  fit <- model_prps$sample(
    data          = stan_data,
    iter_sampling = iter_sampling,
    iter_warmup   = iter_warmup,
    chains        = chains,
    parallel_chains = chains,
    refresh       = refresh,
    thin          = thin,
    show_messages = if_show_messages,
    output_dir = post_draws_path_NFRM
  )
  
  out <- list(
    files   = fit$output_files(),  # only save the path
    n_weeks = n_weeks,
    run     = run
  )
  rm(fit); gc()                    # release RAM
  out
})

# 4) Result
files_prps_NFRM <- map(results_prps_NFRM, "files")

t1_prps_NFRM <- Sys.time()
```

```{r}
# only read last Lth N
# for RMSP, RMSPE, etc.
get_N_lastL_mean <- function(files, wks, L) {
  fit2 <- as_cmdstan_fit(files)
  vars <- paste0("N[", (wks - L + 1):wks, "]")
  s    <- fit2$summary(variables = vars)$mean  # 
  rm(fit2); gc()
  s
}

# for CRPS
get_N_lastL_draws <- function(files, wks, L) {
  fit2 <- as_cmdstan_fit(files)
  vars <- paste0("N[", (wks - L + 1):wks, "]")
  dm   <- fit2$draws(variables = vars, format = "draws_matrix")  # draws x L
  mat  <- t(dm)  # L x draws
  rm(fit2, dm); gc()
  mat
}

```


```{r}

n_w        <- length(n_weeks)
total_runs <- n_w * num_sims
last_lens  <- c(3,4, 5, D)

all_results_NFRM <- vector("list", length(last_lens))
names(all_results_NFRM) <- paste0("last_", last_lens)

for (li in seq_along(last_lens)) {
  Print(paste0("The ",li,"th simulations."))
  L <- last_lens[li]

  metrics_prps_NFRM <- replicate(n_w, vector("list", num_sims), simplify = FALSE)
  metrics_bsl_NFRM  <- replicate(n_w, vector("list", num_sims), simplify = FALSE)

  for (i in seq_along(n_weeks)) {
    wks <- n_weeks[i]
    for (run in seq_len(num_sims)) {
      idx <- (run - 1) * n_w + i

      pred_bsl  <- get_N_lastL_mean(files_bsl_NFRM[[idx]],  wks, L)
      pred_prps <- get_N_lastL_mean(files_prps_NFRM[[idx]], wks, L)
      actual    <- tail(data_NFRM[[run]]$case_true[1:wks], L)

      metrics_bsl_NFRM[[i]][[run]]  <- error_metrics(pred_bsl,  actual)
      metrics_prps_NFRM[[i]][[run]] <- error_metrics(pred_prps, actual)
    }
  }

  out <- data.frame(
    last_len = L,
    n_weeks  = n_weeks,
    prps_RMSE  = NA, prps_RMSPE = NA, prps_MAE = NA, prps_MAPE = NA,
    bsl_RMSE   = NA, bsl_RMSPE  = NA, bsl_MAE  = NA, bsl_MAPE  = NA
  )
  for (i in seq_along(n_weeks)) {
    prps_list_NFRM <- metrics_prps_NFRM[[i]]
    bsl_list_NFRM  <- metrics_bsl_NFRM[[i]]

    out$prps_RMSE[i]  <- mean(sapply(prps_list_NFRM, `[[`, "RMSE"))
    out$prps_RMSPE[i] <- mean(sapply(prps_list_NFRM, `[[`, "RMSPE"))
    out$prps_MAE[i]   <- mean(sapply(prps_list_NFRM, `[[`, "MAE"))
    out$prps_MAPE[i]  <- mean(sapply(prps_list_NFRM, `[[`, "MAPE"))

    out$bsl_RMSE[i]   <- mean(sapply(bsl_list_NFRM,  `[[`, "RMSE"))
    out$bsl_RMSPE[i]  <- mean(sapply(bsl_list_NFRM,  `[[`, "RMSPE"))
    out$bsl_MAE[i]    <- mean(sapply(bsl_list_NFRM,  `[[`, "MAE"))
    out$bsl_MAPE[i]   <- mean(sapply(bsl_list_NFRM,  `[[`, "MAPE"))
  }

  all_results_NFRM[[li]] <- out
}

final_tbl_NFRM <- do.call(rbind, all_results_NFRM)
row.names(final_tbl_NFRM) <- NULL

final_long_NFRM <- final_tbl_NFRM %>%
  tidyr::pivot_longer(
    cols      = -c(last_len, n_weeks),
    names_to  = c("model", "metric"),
    names_sep = "_",
    values_to = "value"
  ) %>%
  tidyr::pivot_wider(
    names_from  = model,
    values_from = value
  ) %>%
  dplyr::mutate(across(c(prps, bsl), ~ round(.x, 2)),
                diff_bsl_minus_prps = bsl - prps)

final_long_NFRM

```





```{r}
all_crps_NFRM <- vector("list", length(last_lens))
names(all_crps_NFRM) <- paste0("last_", last_lens)

for (li in seq_along(last_lens)) {
  L <- last_lens[li]

  crps_prps <- numeric(length(n_weeks))
  crps_bsl  <- numeric(length(n_weeks))

  for (i in seq_along(n_weeks)) {
    wks <- n_weeks[i]
    tmp_prps <- numeric(num_sims)
    tmp_bsl  <- numeric(num_sims)

    for (run in seq_len(num_sims)) {
      idx    <- (run - 1) * length(n_weeks) + i
      y_true <- tail(data_NFRM[[run]]$case_true[1:wks], L)


      pred_prps <- get_N_lastL_draws(files_prps_NFRM[[idx]], wks, L)
      pred_bsl  <- get_N_lastL_draws(files_bsl_NFRM[[idx]],  wks, L)

      tmp_prps[run] <- mean(crps_sample(y = y_true, dat = pred_prps))
      tmp_bsl[run]  <- mean(crps_sample(y = y_true, dat = pred_bsl))

      rm(pred_prps, pred_bsl); gc()
    }

    crps_prps[i] <- mean(tmp_prps)
    crps_bsl[i]  <- mean(tmp_bsl)
  }

  all_crps_NFRM[[li]] <- data.frame(
    last_len  = L,
    n_weeks   = n_weeks,
    prps_CRPS = crps_prps,
    bsl_CRPS  = crps_bsl,
    diff_CRPS = crps_bsl - crps_prps
  )
}

final_crps_tbl_NFRM <- do.call(rbind, all_crps_NFRM)
rownames(final_crps_tbl_NFRM) <- NULL
print(final_crps_tbl_NFRM)

```



```{r}
path_to_save_NFRM <- file.path(path_proj, "data", "simulation","results","NFRM")

# sim data
saveRDS(data_NFRM, file = file.path(path_to_save_NFRM, "data_NFRM.rds"))
# path
saveRDS(files_prps_NFRM, file = file.path(path_to_save_NFRM, "files_prps_NFRM.rds"))
saveRDS(files_bsl_NFRM,  file = file.path(path_to_save_NFRM, "files_bsl_NFRM.rds"))
# metrics
saveRDS(final_long_NFRM, file = file.path(path_to_save_NFRM, "final_long_NFRM.rds"))
saveRDS(final_crps_tbl_NFRM, file = file.path(path_to_save_NFRM, "final_crps_tbl_NFRM.rds"))
```


```{r}
files_prps_NFRM <- readRDS(file.path(path_to_save_NFRM, "files_prps_NFRM.rds"))
files_bsl_NFRM  <- readRDS(file.path(path_to_save_NFRM, "files_bsl_NFRM.rds"))

# result table
final_long_NFRM     <- readRDS(file.path(path_to_save_NFRM, "final_long_NFRM.rds"))
final_crps_tbl_NFRM <- readRDS(file.path(path_to_save_NFRM, "final_crps_tbl_NFRM.rds"))

```

