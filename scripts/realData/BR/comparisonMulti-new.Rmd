---
title: "Multi_states_BR"
author: "Yang Xiao"
date: "2025-09-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(cmdstanr)
library(bayesplot)
library(lubridate)
library(SpatialEpi)
```

```{r}
path_proj = here::here()
path_source = file.path(path_proj, "source")

source(file.path(path_source, "functions", "dengue_tracker_functions.R"))
source(file.path(path_source, "functions", "tidy_dengueBR.R"))
source(file.path(path_source, "functions", "fit_function.R"))
source(file.path(path_source, "functions", "metrics.R"))
aweek::set_week_start("Sunday")

path_source_nowcasting <- file.path(dirname(path_proj), "nowcasting", "source")
source(file.path(path_source_nowcasting, "simulation", "simulations_functions_final.R"))
source(file.path(path_source_nowcasting, "functions", "prior_function.R"))
source(file.path(path_source_nowcasting, "functions", "fit_function.R"))
source(file.path(path_source_nowcasting, "functions", "plot_function.R"))

path_source_denguetracker_data <- file.path(dirname(path_proj), "dengue-tracker/data/weekly_data/")
path_source_denguetracker_infodengue <- file.path(path_source_denguetracker_data, "infodengue")
path_source_denguetracker_GT <- file.path(path_source_denguetracker_data, "gtrends")

path_to_draws_BR <- file.path(file.path(dirname(dirname(path_proj)),"projects","draws","BR"))



```


```{r, warning = F}
brazil_ufs <- c(
  "AC", "AL", "AP", "AM",
  "BA", "CE", "DF", #"ES",
  "GO", "MA", "MT", "MS",
  "MG", "PA", "PB", "PR",
  "PE", "PI", "RJ", "RN",
  "RS", "RO", "RR", "SC",
  "SP", "SE", "TO"
)
# cut_off <- 62
cut_off <- 200
case_data <- list()
case_date <- tail(readr::read_csv(file.path(path_source_denguetracker_infodengue,
                                             202519,paste0("AC","_","2025-05-11","_infodengue.csv"))),cut_off)$ew_start
for (i in 1:length(brazil_ufs)) {
  case_data[[brazil_ufs[i]]] <- tail(readr::read_csv(file.path(path_source_denguetracker_infodengue,
                                             202519,paste0(brazil_ufs[i],"_","2025-05-11","_infodengue.csv"))),cut_off)$sum_of_cases  
}
```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
library(readr)
# transfer the data
case_df <- map_dfr(names(case_data), function(uf) {
  tibble(
    date = case_date,
    cases = case_data[[uf]],
    uf = uf
  )
})


ggplot(case_df, aes(x = date, y = cases, color = uf)) +
  geom_line(size = 1) +
  geom_vline(xintercept = as.Date("2024-07-01"), 
             linetype = "dashed", color = "black", size = 0.8) +
  labs(title = NULL,
       x = "Date", y = "Number of Cases") +
  theme_minimal() +
  theme(legend.position = "right")

```

```{r}
# define the date
end_dates <- data.frame(
  uf = c(
  "AC", "AL", "AP", "AM",
  "BA", "CE", "DF", "GO", 
  "MA", "MT", "MS", "MG", 
  "PA", "PB", "PR", "PE", 
  "PI", "RJ", "RN", "RS", 
  "RO", "RR", "SC", "SP", 
  "SE", "TO"
),
date = as.Date(c("2024-07-28","2024-11-10","2024-11-10","2024-07-28",
                 "2024-07-28","2024-07-28","2024-07-28","2024-07-28",
                 "2024-07-28","2024-07-28","2024-07-28","2024-07-28",
                 "2024-07-28","2024-07-28","2024-07-28","2024-09-29",
                 "2024-07-28","2024-07-28","2024-07-28","2024-07-28",
                 "2024-07-28","2024-11-10","2024-07-28","2024-07-28",
                 "2024-09-29","2024-07-28"))
)

actual_cases <- ggplot(case_df, aes(x = date, y = cases)) +
  geom_line(color = "steelblue", size = 0.8) +
  geom_vline(data = end_dates, aes(xintercept = date),
             linetype = "dashed", color = "black", size = 0.8) +
  facet_wrap(~ uf, scales = "free_y", ncol = 6) +
  labs(title = NULL, x = "Date", y = "Number of Cases") +
  theme_minimal(base_size = 12) +
  theme(
    strip.text = element_text(face = "bold"),
    panel.background   = element_rect(fill = "white", colour = NA),
    plot.background    = element_rect(fill = "white", colour = NA),
    panel.grid.major   = element_line(colour = "grey90"),
    panel.grid.minor   = element_line(colour = "grey95"),
    axis.text.x        = element_text(angle = 45, hjust = 1)
  )

print(actual_cases)
ggsave(filename = file.path(path_proj, "plots_to_show", "BR", "actual_cases.png"),
       plot = actual_cases,
       width = 10, height = 8, dpi = 300)



```

```{r}
pop_br <- readxl::read_xlsx(file.path(path_proj, "PAPER", "population_br_per_states_24to25.xlsx"))

total_cases_2024 <- case_df %>%
  filter(year(date) == 2024) %>%          # filter year 2024
  group_by(uf) %>%                        # per state
  summarise(total_cases = sum(cases, na.rm = TRUE)) %>% 
  ungroup() %>%
  left_join(pop_br %>% select(abbreviation, mid2024), 
            by = c("uf" = "abbreviation")) %>% 
  mutate(
    # national rate
    national_rate = sum(total_cases) / sum(mid2024),
    # expected per state
    expected = mid2024 * national_rate,
    # SIR
    SIR = total_cases / expected
  ) %>% # range order
  dplyr::arrange(match(uf, brazil_ufs))

exposure <- total_cases_2024$expected

```


## the test
### function
```{r}
# avoid when actual = 0
safe_rmspe <- function(pred, actual, eps = 1e-8) {
  sqrt(mean(((pred - actual) / pmax(actual, eps))^2, na.rm = TRUE)) * 100
}
safe_mape <- function(pred, actual, eps = 1e-8) {
  mean(abs((pred - actual) / pmax(actual, eps)), na.rm = TRUE) * 100
}
rmse_fun <- function(pred, actual) sqrt(mean((pred - actual)^2, na.rm = TRUE))
mae_fun  <- function(pred, actual) mean(abs(pred - actual), na.rm = TRUE)

# covrage rate
coverage_rate <- function(truth, lwr, upr) {
  mean(truth >= lwr & truth <= upr, na.rm = TRUE)
}


generate_fourier_basis <- function(weeks, H_max = 3, period = 52) {
  if (inherits(weeks, "Date")) {
    weeks <- seq_along(weeks)
  }
  
  angle <- 2 * pi * (weeks - 1) / period
  
  fourier_list <- lapply(1:H_max, function(h) {
    cbind(
      cos = cos(h * angle),
      sin = sin(h * angle)
    )
  })
  
  basis <- do.call(cbind, fourier_list)
  
  # colnames
  colnames(basis) <- unlist(lapply(1:H_max, function(h) {
    c(paste0("cos_h", h), paste0("sin_h", h))
  }))
  
  return(basis)
}

error_metrics <- function(predicted, actual) {
  # same length
  stopifnot(length(predicted) == length(actual))
  
  # RMSE (Root Mean Squared Error)
  rmse <- sqrt(mean((predicted - actual)^2))
  
  # RMSPE (Root Mean Squared Percentage Error)
  rmspe <- sqrt(mean(((predicted - actual)/actual)^2)) * 100
  
  # MAE (Mean Absolute Error)
  mae <- mean(abs(predicted - actual))
  
  # MAPE (Mean Absolute Percentage Error)
  mape <- mean(abs((predicted - actual)/actual)) * 100

  list(RMSE = rmse,
       RMSPE = rmspe,
       MAE = mae,
       MAPE = mape)
}

```

```{r}
fit_dir <- file.path(path_proj, "outputs", "fits")
dir.create(fit_dir, recursive = TRUE, showWarnings = FALSE)

weeks_per_yr <- 52
t <- 1:(weeks_per_yr * 3)
fourier_basis <- generate_fourier_basis(t, H_max = 10, period = weeks_per_yr)
H_used <- 3

 all_states <- c(
   "AC", "AL", "AP", "AM",
   "BA", "CE", "DF", #"ES",
   "GO", "MA", "MT", "MS",
   "MG", "PA", "PB", "PR",
   "PE", "PI", "RJ", "RN",
   "RS", "RO", "RR", "SC",
   "SP", "SE", "TO"
 )       
 E_vec <- exposure$exposure   
 
 
include_GT <- T                      # if include GT

delay_D <- 15
iter_sampling <- 2500
iter_warmup <- 1000
window_length <- 10
thin <- 1
chain_num <- 4
refresh <- 3000

ew_start <- "202410"
ew_end <- "202430"
# step_size <- 5 # previous
step_size <- 3

seed <- 123
```


# MCMC

```{r, message=FALSE}
suppressMessages(
  suppressWarnings(
      for (i in seq_along(all_states)) {
        state_i <- all_states[i]
        E_val   <- E_vec[i]
        cat(sprintf(">>> [MCMC %d/%d] State = %s ...\n", i, length(all_states), state_i))
        
        # baseline (with actual value)
        baseline_i <- get_baseline_data(
          root_dir = path_source_denguetracker_data,
          states   = state_i,
          start    = ew_start,
          end      = ew_end,
          time_unit = "week",
          last_n   = 30  #10
        ) %>%
          add_actual_cases(root_dir_infodengue = path_source_denguetracker_infodengue,
                           state = state_i,
                           202511)
        saveRDS(baseline_i, file.path(fit_dir, sprintf("%s_baseline.rds", state_i)))
      }
    )
  )

```

```{r, message=FALSE}
set.seed(seed)

suppressMessages(
  suppressWarnings(
      for (i in seq_along(all_states)) {
        state_i <- all_states[i]
        E_val   <- E_vec[i]
        cat(sprintf(">>> [MCMC %d/%d] State = %s ...\n", i, length(all_states), state_i))
        
        # M 1：ARABM
        results_i <- run_moving_window(
          root_dir_infodengue = path_source_denguetracker_infodengue,
          root_dir_GT         = path_source_denguetracker_GT,
          state               = state_i,
          full_start          = ew_start,
          full_end            = ew_end,
          step_size           = step_size,
          D                   = delay_D,
          hypers              = hypers_q(phi_ref = 0.2, D_ref = 15, type = "exponential",
                                         alpha_phi = 1.4, sd_log_b = 1, delay_seq = 0:15),
          model_file          = file.path(path_source_nowcasting, "models", "b-ou.stan"),
          model_name          = "ARABM",
          mode                = "expanding",
          iter_sampling       = iter_sampling,
          iter_warmup         = iter_warmup,
          chains              = chain_num,
          refresh             = refresh,
          posterior_draws_path = path_to_draws_BR
        )
        saveRDS(results_i, file.path(fit_dir, sprintf("%s_ARABM_fit.rds", state_i)))
      }
    )
  )

```

```{r, message=FALSE}
set.seed(seed)

suppressMessages(
  suppressWarnings(
      for (i in seq_along(all_states)) {
        state_i <- all_states[i]
        E_val   <- E_vec[i]
        cat(sprintf(">>> [MCMC %d/%d] State = %s ...\n", i, length(all_states), state_i))
        
        # M 2：ARABMwGT (GT + seasonality + E)
        results_wGT_i <- run_moving_window(
          root_dir_infodengue = path_source_denguetracker_infodengue,
          root_dir_GT         = path_source_denguetracker_GT,
          state               = state_i,
          full_start          = ew_start,
          full_end            = ew_end,
          step_size           = step_size,
          D                   = delay_D,
          hypers              = hypers_q(phi_ref = 0.2, D_ref = 15, type = "exponential",
                                         alpha_phi = 1.4, sd_log_b = 1, delay_seq = 0:15),
          E                   = E_val,
          S                   = H_used * 2,
          bases_s             = fourier_basis[, 1:(H_used * 2)],
          model_file          = file.path(path_source, "models", "nowcast_hist_triangle.stan"),
          model_name          = "ARABMwGT",
          mode                = "expanding",
          iter_sampling       = iter_sampling,
          iter_warmup         = iter_warmup,
          chains              = chain_num,
          refresh             = refresh,
          posterior_draws_path = path_to_draws_BR
        )
        saveRDS(results_wGT_i, file.path(fit_dir, sprintf("%s_ARABMwGT_fit.rds", state_i)))
      }
    )
  )

```


```{r, warning=F}
interval_metrics_list <- list()
L <- 4

suppressMessages(
  suppressWarnings(
    # get the metrics
    for (i in seq_along(all_states)){
      state_i <- all_states[i]
      cat(sprintf(">>> [MCMC %d/%d] State = %s ...\n", i, length(all_states), state_i))
      baseline_i   <- readRDS(file.path(fit_dir, sprintf("%s_baseline.rds", state_i)))
      results_i <- readRDS(file.path(fit_dir, sprintf("%s_ARABM_fit.rds", state_i)))
      results_wGT_i <- readRDS(file.path(fit_dir, sprintf("%s_ARABMwGT_fit.rds", state_i)))
      
      true_data <- baseline_i %>% select(ew_start, sum_of_cases_final) %>% unique()
      
      tmp_crps <- tmp_wGT_crps <- numeric(length(results_i))
      tmp_mcr50 <- tmp_wGT_mcr50 <- numeric(length(results_i))
      tmp_mcr95 <- tmp_wGT_mcr95 <- numeric(length(results_i))
      # For each different time T
      for (j in 1:length(results_i)) {
        
          fit <- as_cmdstan_fit(results_i[[j]]$fit_object$output_files())
          fit_wGT <- as_cmdstan_fit(results_wGT_i[[j]]$fit_object$output_files())
          
          # since the number of N is less in the baseline method
          num_N <- ncol(fit$draws(variables = "N", format = "draws_matrix"))
          num_N_wGT <- ncol(fit_wGT$draws(variables = "N", format = "draws_matrix"))
          
          # draws
          pred <- get_N_lastL_draws(results_i[[j]]$fit_object$output_files(), num_N, min(num_N, L))
          pred_wGT <- get_N_lastL_draws(results_wGT_i[[j]]$fit_object$output_files(), num_N_wGT, min(num_N, L)) # num_N is always smaller
          
          pred <- pred[, colSums(is.na(pred)) < nrow(pred)]
          pred_wGT <- pred_wGT[, colSums(is.na(pred_wGT)) < nrow(pred_wGT)]
          
          # get the case of actual sequence
          y_true <- true_data %>% filter(ew_start <= results_i[[j]]$window_end &
                                         ew_start >= results_i[[j]]$window_start) %>%
            select(sum_of_cases_final)
          y_true <- tail(y_true, min(num_N, L))
          
          # crps
          tmp_crps[j] <- mean(crps_sample(y = y_true$sum_of_cases_final, dat = pred))
          tmp_wGT_crps[j]  <- mean(crps_sample(y = y_true$sum_of_cases_final, dat = pred_wGT))
          
          # 50%
          tmp_mcr50[j] <- coverage_rate_sample(y_true$sum_of_cases_final, pred, level = 0.50)
          tmp_wGT_mcr50[j]  <- coverage_rate_sample(y_true$sum_of_cases_final, pred_wGT,  level = 0.50)
          # 95%
          tmp_mcr95[j] <- coverage_rate_sample(y_true$sum_of_cases_final, pred, level = 0.95)
          tmp_wGT_mcr95[j]  <- coverage_rate_sample(y_true$sum_of_cases_final, pred_wGT,  level = 0.95)
      }
        interval_metrics_list[[i]] <- list(
          crps_out = mean(tmp_crps),
          crps_wGT_out = mean(tmp_wGT_crps),
        
          mcr50_out = mean(tmp_mcr50),
          mcr50_wGT_out = mean(tmp_wGT_mcr50),
        
          mcr95_out = mean(tmp_mcr95),
          mcr95_wGT_out = mean(tmp_wGT_mcr95)
        )
}
  )
)


```

```{r}
all_metrics <- list()
include_GT <- T
result_list_allstates <- list()

for (i in seq_along(all_states)) {
  state_i <- all_states[i]
  cat(sprintf(">>> [EVAL %d/%d] State = %s ...\n", i, length(all_states), state_i))
  # read data
  baseline_i   <- readRDS(file.path(fit_dir, sprintf("%s_baseline.rds", state_i)))
  results_i    <- readRDS(file.path(fit_dir, sprintf("%s_ARABM_fit.rds", state_i)))
  results_wGT_i<- readRDS(file.path(fit_dir, sprintf("%s_ARABMwGT_fit.rds", state_i)))
  # results
  arabm_i     <- extract_N_summary(results_i,    num_N = 4) # 
  arabm_wGT_i <- extract_N_summary(results_wGT_i,num_N = 4, model_name = "ARABMwGT")
  
  result_out_i <- baseline_i %>%
    left_join(arabm_i %>% select(ew_now, ew, ARABM, ARABM_lwr, ARABM_upr),
              by = c("ew_now", "ew")) %>%
    left_join(arabm_wGT_i %>% select(ew_now, ew, ARABMwGT, ARABMwGT_lwr, ARABMwGT_upr),
              by = c("ew_now", "ew"))
  # get the latest week
  n_last <- L
  result_out_cut <- result_out_i %>%
    filter(!is.na(ARABM)) %>%
    group_by(ew_now) %>%
    slice_max(order_by = ew, n = n_last) %>%
    ungroup()
  # true number of cases
  truth <- result_out_cut$sum_of_cases_final
  
  result_list_allstates[[state_i]] <- result_out_cut
  
  metric_tbl_all <- result_out_cut %>%
    pivot_longer(
      cols = c(cases_est_id, ARABM, ARABMwGT),
      names_to = "model",
      values_to = "pred"
    ) %>% mutate(model = recode(model, cases_est_id = "Bastos")) %>%
    select(file_date, model, pred, sum_of_cases_final) %>%
   group_by(file_date, model) %>%
    summarise(
      RMSE  = rmse_fun(pred, sum_of_cases_final),
      RMSPE = safe_rmspe(pred, sum_of_cases_final),
      MAE   = mae_fun(pred, sum_of_cases_final),
      MAPE  = safe_mape(pred, sum_of_cases_final),
      .groups = "drop"
    )  
  
  metric_tbl <- metric_tbl_all %>%   group_by(model) %>%
  summarise(
    RMSE  = mean(RMSE,  na.rm = TRUE),
    RMSPE = mean(RMSPE, na.rm = TRUE),
    MAE   = mean(MAE,   na.rm = TRUE),
    MAPE  = mean(MAPE,  na.rm = TRUE),
    .groups = "drop"
  )%>%  mutate(state = state_i) %>%
    relocate(state, model) 
  
  interval_tbl <- tibble(
  model = c("Bastos", "ARABM", "ARABMwGT"),
  crps  = c(NA_real_, interval_metrics_list[[i]]$crps_out,   interval_metrics_list[[i]]$crps_wGT_out),
  mcr95 = c(NA_real_, interval_metrics_list[[i]]$mcr95_out,  interval_metrics_list[[i]]$mcr95_wGT_out),
  mcr50 = c(NA_real_, interval_metrics_list[[i]]$mcr50_out,  interval_metrics_list[[i]]$mcr50_wGT_out)
  )

  metric_tbl <- metric_tbl %>%
    left_join(interval_tbl, by = "model") %>%
    relocate(state, model, RMSE, RMSPE, MAE, MAPE, crps, mcr95, mcr50)
  
  # optional for GT
  if (include_GT && "GT" %in% names(result_out_cut)) {
    metric_tbl <- bind_rows(
      tibble(
        state = state_i,
        model = "GT",
        RMSE  = rmse_fun(result_out_cut$GT, truth),
        RMSPE = safe_rmspe(result_out_cut$GT, truth),
        MAE   = mae_fun(result_out_cut$GT, truth),
        MAPE  = safe_mape(result_out_cut$GT, truth),
        crps  = NA_real_,  
        mcr95  = NA_real_,
        mcr50  = NA_real_
      ),
      metric_tbl
    )
  }
  
  all_metrics[[state_i]] <- metric_tbl
}

# combine all states
final_metrics <- bind_rows(all_metrics)

# general table
out_dir <- file.path(path_proj, "outputs")
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
readr::write_csv(final_metrics, file.path(out_dir, "multi_state_metrics_with_crps_coverage.csv"))

cat(">>> Done. Combined metrics saved to: ",
    file.path(out_dir, "multi_state_metrics_with_crps_coverage.csv"), "\n")

```

```{r}
library(dplyr)
library(tidyr)
# for latex table

final_metrics_out <- final_metrics %>%
  filter(model %in% c("ARABM", "ARABMwGT")) %>%
  mutate(model = recode(model, ARABM = "Baseline", ARABMwGT = "Proposed")) %>%
  # wider
  pivot_wider(
    id_cols = state, names_from = model,
    values_from = c(RMSE, RMSPE, crps, mcr95, mcr50),
    names_glue = "{.value}:{model}"
  ) %>%
  mutate(across(where(is.numeric), ~round(.x,2)))

final_metrics_out_hl <- highlight_metric_pairs_simple(
      df_wide    = final_metrics_out,
      metrics    = c("RMSE", "RMSPE", "crps" ,"mcr95", "mcr50"),
      directions = c(RMSE="lower", RMSPE="lower", mcr95="closer", mcr50="closer", crps="lower"),
      targets    = c(CR95=0.95, CR50=0.50),  # or 95/50 if your data are percentages
      color = "red",
      tie_highlight = FALSE                   # <- no highlight on ties
)

cat(render_latex_metric_pairs(
    df_print = final_metrics_out_hl))


```

```{r}
library(writexl)

# write
write_xlsx(final_metrics, file.path(path_proj, "plots_to_show","BR","final_metrics.xlsx"))

```


```{r}

#calculate report proportion for discussion
result_out_cut_delay <-result_out_cut %>% mutate(delay = as.numeric(ew_now) - as.numeric(ew))

d0 <- result_out_cut_delay %>% filter(delay == 0)
d1 <- result_out_cut_delay %>% filter(delay == 1)
d2 <- result_out_cut_delay %>% filter(delay == 2)
d3 <- result_out_cut_delay %>% filter(delay == 3)

d0$sum_of_cases  /d0$sum_of_cases_final
d1$sum_of_cases  /d1$sum_of_cases_final
d2$sum_of_cases  /d2$sum_of_cases_final
d3$sum_of_cases  /d3$sum_of_cases_final

mean(d0$sum_of_cases  /d0$sum_of_cases_final)
mean(d1$sum_of_cases  /d1$sum_of_cases_final)
mean(d2$sum_of_cases  /d2$sum_of_cases_final)
mean(d3$sum_of_cases  /d3$sum_of_cases_final)
```



## plot

### get data first
```{r}
make_state_summary_from_results <- function(state_name, baseline, results_bsl, results_prsp, levels) {
  purrr::map_dfr(seq(length(results_bsl)), function(idx) {
    res_bsl <- results_bsl[[idx]]
    res_prsp <- results_prsp[[idx]]
    
    # get the time horizon
    start_date <- res_bsl$window_start
    end_date <- res_bsl$window_end
    wks_now       <- date_to_ew(end_date)
    
    # get the number acual/reported cases
    actual_cases <- baseline %>% filter(ew_now == wks_now & ew_start <= end_date &
                                          ew_start >= start_date) %>% select(sum_of_cases_final)
    reported_cases <- baseline %>% filter(ew_now == wks_now & ew_start <= end_date &
                                            ew_start >= start_date) %>%select(sum_of_cases)

    N_num <- nrow(actual_cases) 
    pred_weeks <- seq(as.numeric(wks_now) - N_num + 1, as.numeric(wks_now))

    # get draws
    draws_bsl <-  t(res_bsl$fit_object$draws(variables = "N", format = "draws_matrix"))
    draws_bsl <- draws_bsl[, colSums(is.na(draws_bsl)) < nrow(draws_bsl)] # remove NAs 
    sum_bsl   <- summarise_draws_mat(draws_bsl, levels = levels) %>%
      dplyr::mutate(model = "Baseline", week = wks_now, actual = actual_cases$sum_of_cases_final,
                    reported = reported_cases$sum_of_cases, window_L = N_num, eval_t = wks_now, pred_weeks)
    # Proposed
    draws_prps <- t(res_prsp$fit_object$draws(variables = "N", format = "draws_matrix"))
    draws_prps <- tail(draws_prps, N_num)
    draws_prps <- draws_prps[, colSums(is.na(draws_prps)) < nrow(draws_prps)]
    sum_prps   <- summarise_draws_mat(draws_prps, levels = levels) %>%
      dplyr::mutate(model = "Proposed", week = wks_now, actual = actual_cases$sum_of_cases_final,
                    reported = reported_cases$sum_of_cases, window_L = N_num, eval_t = wks_now, pred_weeks)
    
    dplyr::bind_rows(sum_prps, sum_bsl) %>%
      dplyr::mutate(state = state_name) %>%
      dplyr::relocate(state, eval_t, pred_weeks, window_L, model, actual, reported, mean, l50, u50, l95, u95)
  })
}

# states <- c("AM","RJ","SP") 
states <- c("AM", "RJ", "SE")
plot_levels <- c(0.50, 0.95)
data_plot <- data.frame()
for(i in states){
  state_i <- i
  baseline   <- readRDS(file.path(fit_dir, sprintf("%s_baseline.rds", state_i)))
  results_bsl <- readRDS(file.path(fit_dir, sprintf("%s_ARABM_fit.rds", state_i)))
  results_prsp <- readRDS(file.path(fit_dir, sprintf("%s_ARABMwGT_fit.rds", state_i)))
  temp <- make_state_summary_from_results(state_i, baseline, results_bsl, results_prsp, plot_levels)
  data_plot <- dplyr::bind_rows(data_plot, temp)
}

```



```{r}
library(dplyr)
library(ggplot2)
state_actual_range <- data_plot %>%
  group_by(state) %>%
  summarise(
    min_actual = min(actual, na.rm = TRUE),
    max_actual = max(actual, na.rm = TRUE),
    .groups = "drop"
  )

print(state_actual_range)

# ---- choose CI level ----
ci_level <- 0.95
tag      <- as.integer(round(ci_level * 100))
lcol     <- paste0("l", tag)
ucol     <- paste0("u", tag)

# ---- filter & order ----
df_plot <- data_plot %>%
  mutate(
    model = factor(model, levels = c("Baseline","Proposed"))
  )


eval_times   <- sort(unique(df_plot$eval_t))
eval_labels  <- paste0("t = ", eval_times)
df_plot <- df_plot %>%
  mutate(
    eval_lab = factor(paste0("t = ", eval_t),
                      levels = eval_labels)
  )

```


```{r}
library(ggh4x)

# ---- colors ----
method_colors <- c(
  "Baseline"       = "#96C37D",
  "Proposed"       = "#2F7FC1",
  "Actual cases"   = "#C82423",
  "Reported cases" = "black"
)


# Manually setting the limit
y_limits <- tibble::tibble(
  state = states,
  y_min = c(0,    0,     0),
  y_max = c(2500, 35000, 1000)
)

p <- ggplot(df_plot, aes(x = pred_weeks)) +
  geom_ribbon(
    aes(ymin = .data[[lcol]], ymax = .data[[ucol]],
        fill = model,
        group = interaction(state, model, eval_lab)),
    alpha = 0.25, show.legend = FALSE, na.rm = TRUE
  ) +
  geom_line(
    aes(y = mean, color = model,
        group = interaction(state, model, eval_lab)),
    linewidth = 0.4, show.legend = FALSE, na.rm = TRUE
  ) +
  geom_line(
    aes(y = reported, color = "Reported cases",
        group = interaction(state, model, eval_lab)),
    linewidth = 0.4, show.legend = TRUE, na.rm = TRUE
  ) +
  geom_point(
    aes(y = reported, color = "Reported cases",
        group = interaction(state, model, eval_lab)),
    size = 0.5, show.legend = TRUE, na.rm = TRUE
  ) +
  geom_line(
    aes(y = actual, color = "Actual cases",
        group = interaction(state, model, eval_lab)),
    linewidth = 0.5, linetype = 6, show.legend = TRUE, na.rm = TRUE
  ) +
  facet_grid(
    rows = vars(state, model),
    cols = vars(eval_lab),
    scales = "free_y",   
    switch = "y"
  ) +
  scale_color_manual(
    values = method_colors,
    breaks = c("Actual cases","Reported cases"),
    name = NULL
  ) +
  scale_fill_manual(
    values = method_colors[c("Baseline","Proposed")],
    guide = "none"
  ) +
  labs(x = NULL, y = "Number of cases") +
  theme_bw(base_size = 10) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # x 45°
    legend.position      = c(0.15, 0.995),
    legend.justification = c(1, 1),
    legend.background    = element_rect(fill = scales::alpha("white", 0.75), color = NA),
    legend.key.height    = unit(0.25, "cm"),
    legend.key.width     = unit(0.5, "cm"),
    legend.text          = element_text(size = 7),
    strip.background     = element_blank(),
    strip.text           = element_text(face = "bold"),
    panel.grid.minor     = element_blank(),
    panel.grid.major.x   = element_blank(),
    axis.title.y         = element_text(margin = margin(r = 6))
  )

# diff y axis
p <- p + ggh4x::facetted_pos_scales(
  y = list(
    state %in% states[1] ~ scale_y_continuous(
      limits = c(y_limits$y_min[y_limits$state == states[1]],
                 y_limits$y_max[y_limits$state == states[1]])
    ),
    state %in% states[2] ~ scale_y_continuous(
      limits = c(y_limits$y_min[y_limits$state == states[2]],
                 y_limits$y_max[y_limits$state == states[2]])
    ),
    state %in% states[3] ~ scale_y_continuous(
      limits = c(y_limits$y_min[y_limits$state == states[3]],
                 y_limits$y_max[y_limits$state == states[3]])
    )
  )
)


print(p)
```

```{r}
ggsave(filename = file.path(path_proj, "plots_to_show", "BR", "results.png"),
       plot = p,
       width = 12, height = 8, dpi = 300)
```

